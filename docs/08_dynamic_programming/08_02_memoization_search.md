## 1. 记忆化搜索简介

> **记忆化搜索（Memoization Search）**：是一种通过记录已访问状态的结果，避免对同一状态进行重复计算的高效搜索方法。

记忆化搜索本质上是动态规划的一种实现方式。其核心思想是在递归求解子问题时，先判断该子问题是否已经被计算过——如果有，则直接返回缓存结果；如果没有，则递归计算，并将结果存入缓存，供后续复用。

以「斐波那契数列」为例，其定义为：$f(0) = 0, f(1) = 1, f(n) = f(n - 1) + f(n - 2)$。如果直接递归求解第 $n$ 项，递归树会出现大量重复计算：

![记忆化搜索](https://qcdn.itcharge.cn/images/20240514110503.png)

如上图所示，普通递归在计算 $f(5)$ 时，会多次计算 $f(3)$、$f(2)$ 等子问题，导致效率低下。

为避免这种重复，记忆化搜索在递归过程中引入缓存（如数组或哈希表），每当递归到 $f(k)$ 时，先检查缓存中是否已有结果——若有则直接返回，无需再次递归。这样即可显著减少重复计算，提高效率。

下面是用记忆化搜索实现斐波那契数列的示例代码：

```python
class Solution:
    def fib(self, n: int) -> int:
        # 初始化备忘录数组，memo[i] 用于存储 f(i) 的计算结果，避免重复递归
        memo = [0 for _ in range(n + 1)]
        return self.my_fib(n, memo)

    def my_fib(self, n: int, memo: List[int]) -> int:
        # 边界情况：n 为 0 时，斐波那契数为 0
        if n == 0:
            return 0
        # 边界情况：n 为 1 时，斐波那契数为 1
        if n == 1:
            return 1
        
        # 如果 f(n) 已经计算过，直接返回缓存结果，避免重复计算
        if memo[n] != 0:
            return memo[n]
        
        # 递归计算 f(n - 1) 和 f(n - 2)，并将结果存入备忘录
        memo[n] = self.my_fib(n - 1, memo) + self.my_fib(n - 2, memo)
        return memo[n]
```

## 2. 记忆化搜索与递推的区别

「记忆化搜索」和「递推」都是动态规划的常用实现方式，但两者在思路和实现上存在明显差异：

> **记忆化搜索**：采用「自顶向下」的递归方式解决问题。每当遇到一个子问题时，先判断其结果是否已被计算并缓存（通常用数组或哈希表存储），如果已缓存则直接返回，否则递归计算并缓存结果，避免重复计算。
>
> - **优点**：代码结构直观，易于理解，尤其适合处理状态转移方程复杂、难以直接递推出解的问题。通过递归自然地分解子问题，便于实现。
> - **缺点**：递归层数过深时，可能导致栈溢出，空间消耗较大。

> **递推**：采用「自底向上」的循环方式解决问题。通过预先确定的顺序，逐步计算并保存每个子问题的解，最终得到原问题的答案。
>
> - **优点**：避免了递归带来的栈溢出风险，计算顺序清晰，通常空间和时间效率更高。
> - **缺点**：对于状态转移方程复杂、依赖关系不明确的问题，递推实现较为困难，代码可读性和灵活性较差。

**选择建议**：

- 适合使用记忆化搜索的场景：
  1. 状态转移方程复杂，难以直接递推出解。
  2. 问题本身适合递归建模，且递归深度可控。

- 适合使用递推的场景：
  1. 状态转移方程简单明了，递推关系清晰。
  2. 递归深度过大，担心栈溢出，或希望提升空间效率。

## 3. 记忆化搜索的解题步骤

使用记忆化搜索时，通常遵循以下步骤：

1. 明确问题的动态规划「状态」以及「状态转移方程」。
2. 定义一个缓存结构（如数组或哈希表），用于存储已计算过的子问题结果，避免重复计算。
3. 编写递归函数：每次递归时，先判断当前子问题的解是否已在缓存中，若有则直接返回，否则递归计算，并将结果存入缓存后返回。
4. 在主函数中初始化缓存，并调用递归函数获取最终答案。

## 4. 记忆化搜索的应用

### 4.1 经典例题：目标和

#### 4.1.1 题目链接

- [494. 目标和 - 力扣](https://leetcode.cn/problems/target-sum/)

#### 4.1.2 题目大意

**描述**：给定一个整数数组 $nums$ 和一个整数 $target$。数组长度不超过 $20$。向数组中每个整数前加 `+` 或 `-`。然后串联起来构造成一个表达式。

**要求**：返回通过上述方法构造的、运算结果等于 $target$ 的不同表达式数目。

**说明**：

- $1 \le nums.length \le 20$。
- $0 \le nums[i] \le 1000$。
- $0 \le sum(nums[i]) \le 1000$。
- $-1000 \le target \le 1000$。

**示例**：

- 示例 1：

```python
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

- 示例 2：

```python
输入：nums = [1], target = 1
输出：1
```

#### 4.1.3 解题思路

##### 思路 1：深度优先搜索（超时）

采用深度优先搜索（DFS）的方法，对每个数字尝试添加 `+` 或 `-`，具体步骤如下：

1. 定义递归函数 `dfs(i, cur_sum)`，表示从下标 $i$ 开始，当前累加和为 $cur\_sum$ 时，能够得到目标和 $target$ 的方案数。
2. 初始调用为 `dfs(0, 0)`，即从第一个数字、当前和为 $0$ 开始递归。
3. 递归终止条件：当 $i$ 等于数组长度 $size$ 时，说明已经处理完所有数字。
   - 如果此时 $cur\_sum$ 等于 $target$，返回 $1$，表示找到一种可行方案。
   - 否则返回 $0$，表示当前路径不可行。
4. 对于每个位置 $i$，递归地分别尝试加上 $nums[i]$ 和减去 $nums[i]$，即：
   - 递归调用 `dfs(i + 1, cur_sum + nums[i])`
   - 递归调用 `dfs(i + 1, cur_sum - nums[i])`
5. 将上述两种选择的返回值相加，得到当前位置 $i$、当前和 $cur\_sum$ 下的总方案数，并返回。
6. 最终答案即为 `dfs(0, 0)` 的返回值。

这种方法会遍历所有可能的加减组合，统计满足条件的方案数。

##### 思路 1：代码

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        size = len(nums)

        def dfs(i, cur_sum):
            if i == size:
                if cur_sum == target:
                    return 1
                else:
                    return 0
            ans = dfs(i + 1, cur_sum - nums[i]) + dfs(i + 1, cur_sum + nums[i])
            return ans
        
        return dfs(0, 0)
```

##### 思路 1：复杂度分析

- **时间复杂度**：$O(2^n)$。其中 $n$ 为数组 $nums$ 的长度。
- **空间复杂度**：$O(n)$。递归调用的栈空间深度不超过 $n$。

##### 思路 2：记忆化搜索

在思路 1 中，单纯使用深度优先搜索（DFS）对每个数字尝试加号或减号，导致大量重复计算，最终超时。为此，我们引入记忆化搜索，通过缓存中间结果来避免重复递归。

具体做法如下：

1. 使用哈希表 $table$ 记录每个状态 $(i, cur\_sum)$ 下的方案数，$i$ 表示当前处理到的下标，$cur\_sum$ 表示当前累加和。
2. 定义递归函数 `dfs(i, cur_sum)`，表示从下标 $i$ 开始，当前累加和为 $cur\_sum$ 时，能够得到目标和 $target$ 的方案数。初始调用为 `dfs(0, 0)`。
3. 递归终止条件：当 $i$ 等于数组长度时，如果 $cur\_sum = target$，返回 $1$，否则返回 $0$。
4. 如果状态 $(i, cur\_sum)$ 已经在 $table$ 中，直接返回缓存的结果，避免重复计算。
5. 否则，递归计算两种选择的方案数：
   - 选择 $nums[i]$ 加号：`dfs(i + 1, cur_sum + nums[i])`
   - 选择 $nums[i]$ 减号：`dfs(i + 1, cur_sum - nums[i])`
   将两者结果相加，得到当前状态的总方案数，并存入 $table$。
6. 最终返回 `dfs(0, 0)` 作为答案。

通过记忆化搜索，大幅减少了重复子问题的计算，提高了效率。

##### 思路 2：代码

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        size = len(nums)
        table = dict()

        def dfs(i, cur_sum):
            if i == size:
                if cur_sum == target:
                    return 1
                else:
                    return 0
                    
            if (i, cur_sum) in table:
                return table[(i, cur_sum)]
            
            cnt = dfs(i + 1, cur_sum - nums[i]) + dfs(i + 1, cur_sum + nums[i])
            table[(i, cur_sum)] = cnt
            return cnt

        return dfs(0, 0)
```

##### 思路 2：复杂度分析

- **时间复杂度**：$O(2^n)$。其中 $n$ 为数组 $nums$ 的长度。
- **空间复杂度**：$O(n)$。递归调用的栈空间深度不超过 $n$。

### 4.2 经典例题：第 N 个泰波那契数

#### 4.2.1 题目链接

- [1137. 第 N 个泰波那契数 - 力扣](https://leetcode.cn/problems/n-th-tribonacci-number/)

#### 4.2.2 题目大意

**描述**：给定一个整数 $n$。

**要求**：返回第 $n$ 个泰波那契数。

**说明**：

- **泰波那契数**：$T_0 = 0, T_1 = 1, T_2 = 1$，且在 $n >= 0$ 的条件下，$T_{n + 3} = T_{n} + T_{n+1} + T_{n+2}$。
- $0 \le n \le 37$。
- 答案保证是一个 32 位整数，即 $answer \le 2^{31} - 1$。

**示例**：

- 示例 1：

```python
输入：n = 4
输出：4
解释：
T_3 = 0 + 1 + 1 = 2
T_4 = 1 + 1 + 2 = 4
```

- 示例 2：

```python
输入：n = 25
输出：1389537
```

#### 4.2.3 解题思路

##### 思路 1：记忆化搜索

1. 状态定义：用 $T_n$ 表示第 $n$ 个泰波那契数。状态转移方程为：$T_0 = 0, T_1 = 1, T_2 = 1$，当 $n \ge 3$ 时，$T_n = T_{n-1} + T_{n-2} + T_{n-3}$。
2. 使用一个长度为 $n + 1$ 的数组 $memo$，用于记录已经计算过的泰波那契数，避免重复计算。
3. 定义递归函数 `my_tribonacci(n, memo)`，实现如下：
   1. 如果 $n = 0$，返回 $0$；若 $n = 1$ 或 $n = 2$，返回 $1$。
   2. 如果 $memo[n]$ 已经被赋值（即 $memo[n] \ne 0$），直接返回 $memo[n]$。
   3. 否则递归计算 $my\_tribonacci(n - 1, memo)$、$my\_tribonacci(n - 2, memo)$ 和 $my\_tribonacci(n-3, memo)$，将三者之和赋值给 $memo[n]$，并返回 $memo[n]$。

##### 思路 1：代码

```python
class Solution:
    def tribonacci(self, n: int) -> int:
        # 使用数组保存已经求解过的 T(k) 的结果
        memo = [0 for _ in range(n + 1)]
        return self.my_tribonacci(n, memo)
    
    def my_tribonacci(self, n: int, memo: List[int]) -> int:
        if n == 0:
            return 0
        if n == 1 or n == 2:
            return 1
        
        if memo[n] != 0:
            return memo[n]
        memo[n] = self.my_tribonacci(n - 3, memo) + self.my_tribonacci(n - 2, memo) + self.my_tribonacci(n - 1, memo)
        return memo[n]
```

##### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。
- **空间复杂度**：$O(n)$。

## 5. 总结

记忆化搜索是动态规划的一种重要实现方式，通过缓存已计算过的子问题结果来避免重复计算，从而显著提高算法效率。其核心思想是在递归求解过程中，先检查当前状态是否已被计算过，如果有则直接返回缓存结果，否则递归计算并将结果存入缓存。

记忆化搜索采用自顶向下的递归方式，代码结构直观易懂，特别适合处理状态转移方程复杂、难以直接递推的问题。通过递归自然地分解子问题，使得复杂问题的建模变得相对简单。然而，递归深度过深时可能导致栈溢出，且空间消耗相对较大。

在实际应用中，记忆化搜索广泛应用于各种动态规划问题，如斐波那契数列、目标和问题、泰波那契数等。通过合理使用记忆化技术，可以将原本指数级的时间复杂度降低到多项式级别，大大提升算法性能。

选择记忆化搜索还是递推方式，需要根据具体问题的特点来决定。对于状态转移方程复杂、递归深度可控的问题，记忆化搜索是很好的选择；而对于状态转移简单、需要优化空间效率的问题，递推方式可能更为合适。


## 题目练习

- [0494. 目标和](https://github.com/ITCharge/AlgoNote/tree/main/docs/solutions/0400-0499/target-sum.md)
- [1137. 第 N 个泰波那契数](https://github.com/ITCharge/AlgoNote/tree/main/docs/solutions/1100-1199/n-th-tribonacci-number.md)
- [0576. 出界的路径数](https://github.com/ITCharge/AlgoNote/tree/main/docs/solutions/0500-0599/out-of-boundary-paths.md)


- [记忆化搜索题目](https://github.com/ITCharge/AlgoNote/tree/main/docs/00_preface/00_06_categories_list.md#%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E9%A2%98%E7%9B%AE)

## 参考资料

1. 【文章】[记忆化搜索 - OI Wiki](https://oi-wiki.org/dp/memo/)
