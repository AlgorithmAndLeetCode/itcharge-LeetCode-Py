## 1. 动态规划简介

### 1.1 动态规划的定义

> **动态规划（Dynamic Programming，DP）**：是一种通过将复杂问题分解为若干相互重叠的子问题，逐步求解并保存子问题结果，最终获得原问题最优解的方法。动态规划强调阶段性决策和结果复用，避免重复计算，从而高效解决多阶段最优化问题。

动态规划由理查德·贝尔曼于 1957 年提出。这里的 Programming 指的是「规划」或「表格法」，即把每一步的计算结果记录下来，避免重复计算。

### 1.2 动态规划的核心思想

> **动态规划的核心思想**：
>
> 1. 将复杂的原问题拆解为若干个相互重叠的子问题，每个子问题的求解过程可视为一个 **「阶段」**。每完成一个阶段的计算，才进入下一个阶段。
> 2. 在求解子问题时，采用「自顶向下的记忆化搜索」或「自底向上的递推」方式，将每个子问题的解保存到表格（数组 / 哈希表）中。这样，当后续需要用到某个子问题的解时，可以直接查表，避免重复计算。

动态规划与分治算法类似，都采用「分而治之」的思想，但两者的区别在于：

1. 动态规划适用于子问题之间存在重叠的场景，即分解后得到的子问题并非完全独立，而是相互关联、会被多次重复求解。
2. 动态规划通过将这些重叠子问题的解存储下来，后续直接复用，极大减少了重复计算，提高了效率。

### 1.3 动态规划的简单例子

我们先通过一个经典例子直观理解动态规划的思想，再进一步介绍相关术语。

> **斐波那契数列**：该数列以 $f(0) = 0, f(1) = 1$ 为起点，每一项均为前两项之和，即：
>
> $f(n) = \begin{cases} 0 & n = 0 \\ 1 & n = 1 \\ f(n - 2) + f(n - 1) & n > 1 \end{cases}$

根据递推公式 $f(n) = f(n-2) + f(n-1)$，我们可以将原问题 $f(n)$ 递归的拆解为两个子问题 $f(n-2)$ 和 $f(n-1)$。如下图所示：

![斐波那契数列的重复计算项](https://qcdn.itcharge.cn/images/20230307164107.png)

从图中可以看到，如果直接递归计算 $f(5)$，会多次重复计算 $f(3)$、$f(2)$ 等子问题，导致效率低下。

为避免重复计算，动态规划采用「表格法」：将每个子问题的结果记录下来，后续直接查表即可。

以「自底向上」的递推方式为例，步骤如下：

1. 定义数组 $dp$，用于存储斐波那契数列的各项值。
2. 初始化 $dp[0] = 0, dp[1] = 1$。
3. 按递推公式 $f(n) = f(n-1) + f(n-2)$，从 $dp[2]$ 开始依次计算，直到 $dp[n]$。
4. 返回 $dp[n]$，即为第 $n$ 项斐波那契数。

具体代码如下：

```python
class Solution:
    def fib(self, n: int) -> int:
        # 边界情况：n 为 0 时，斐波那契数为 0
        if n == 0:
            return 0
        # 边界情况：n 为 1 时，斐波那契数为 1
        if n == 1:
            return 1

        # 初始化dp数组，dp[i] 表示第 i 个斐波那契数
        dp = [0 for _ in range(n + 1)]
        dp[0] = 0  # 第 0 项
        dp[1] = 1  # 第 1 项

        # 自底向上递推，依次计算每一项
        for i in range(2, n + 1):
            # 状态转移方程：第 i 项等于前两项之和
            dp[i] = dp[i - 2] + dp[i - 1]

        # 返回第 n 项斐波那契数
        return dp[n]
```

这种通过缓存（如哈希表、集合或数组）存储已计算结果，避免对子问题的重复求解的方法，就是「动态规划」的核心思想。

## 2. 动态规划的三大特征

什么样的问题适合用动态规划解决？本质上，只有同时满足以下三个特征的问题，才适合用动态规划方法高效求解：

1. **最优子结构**
2. **重叠子问题**
3. **无后效性**

### 2.1 最优子结构

> **最优子结构**：即一个问题的最优解可以由其子问题的最优解推导得到。

通俗来说，如果我们能把原问题分解为若干子问题，并且原问题的最优解一定包含这些子问题的最优解，那么该问题就具备最优子结构。例如，设原问题 $S = \lbrace a_1, a_2, a_3, a_4 \rbrace$，在第 $a_1$ 步选出当前最优后，剩下的子问题 $S_{\text{子问题}} = \lbrace a_2, a_3, a_4 \rbrace$ 的最优解也必须包含在整体最优解中。

![最优子结构性质](https://qcdn.itcharge.cn/images/20240513163310.png)

### 2.2 重叠子问题

> **重叠子问题**：即在递归求解过程中，会反复遇到相同的子问题。

动态规划与分治法的最大区别在于，动态规划适用于子问题会被多次重复计算的场景。比如斐波那契数列，$f(2)$、$f(3)$ 等子问题会被多次递归调用。动态规划通过将子问题的解存储下来（如用数组或哈希表），避免了重复计算，大大提升了效率。

![重叠子问题性质](https://qcdn.itcharge.cn/images/20230307164107.png)

### 2.3 无后效性

> **无后效性**：指某一阶段的状态一旦确定，不会被后续阶段的决策所影响。

也就是说，**子问题的解一旦确定，就不会再被修改**。例如，在有向无环图中求最短路径时，假设已知 $A$ 到 $D$ 的最短路径为 $9$，那么无论后续如何选择路径，都不会影响 $A$ 到 $D$ 的最短路径长度。这种前面的决策不会被后面的决策反悔就是「无后效性」。

如果问题存在「后效性」，则需要先消除后效性（如逆序建模），否则无法直接用动态规划求解。

![无后效性](https://qcdn.itcharge.cn/images/20240514110127.png)

## 3. 动态规划的基本思路

如下图所示，动态规划在解决最优化问题时，通常会将整个求解过程按照一定的顺序（如时间、空间等）划分为若干相互关联的「阶段」。在每个阶段，我们需要做出一个「决策」，该决策不仅影响当前阶段的收益，还会决定下一阶段的初始状态。依次完成每个阶段的决策后，就形成了从起点到终点的完整决策序列。

通过这种方式，原问题被拆解为一系列相互联系的子问题，逐步递推求解，最终获得整体问题的最优解。

![动态规划方法](https://qcdn.itcharge.cn/images/20240514110154.png)

这种具有前后依赖关系、链式结构的多阶段决策问题，通常被称为「多阶段决策问题」。

动态规划的基本步骤如下：

1. **划分阶段**：将原问题按照某种顺序（如时间、空间等）分解为若干有序的阶段。每个阶段对应一个子问题，阶段之间存在明确的先后关系。
2. **定义状态**：用适当的变量（如位置、数量、容量等）描述每个阶段的状态。状态的设计需满足无后效性，即一旦确定不会被后续决策影响。
3. **状态转移方程**：根据前一阶段的状态和当前可做的决策，推导出当前阶段的状态。即通过状态转移方程描述各阶段状态之间的递推关系。
4. **初始条件与边界条件**：结合问题描述、状态定义和状态转移方程，明确初始状态和边界情况，为递推提供基础。
5. **确定最终结果**：根据递推过程和问题目标，提取或计算出最终所需的答案。

通过上述步骤，可以系统性地将原问题拆解、建模并高效求解。

## 4. 动态规划的应用

动态规划问题通常灵活多变，思维难度较高，缺乏固定的解题模板，因此在各类算法竞赛和面试中频繁出现。

解决动态规划问题的核心在于「状态的设计」与「状态转移方程的推导」，同时还需掌握多种优化技巧。要想真正掌握动态规划，必须通过大量练习和总结，积累不同题型的经验，才能灵活运用动态规划思想。

下面将介绍几道动态规划的基础题目，帮助大家理解和掌握基本方法。

### 4.1 经典例题：斐波那契数

#### 4.1.1 题目链接

- [509. 斐波那契数 - 力扣](https://leetcode.cn/problems/fibonacci-number/)

#### 4.1.2 题目大意

**描述**：给定一个整数 $n$。

**要求**：计算第 $n$ 个斐波那契数。

**说明**：

- 斐波那契数列的定义如下：
  - $f(0) = 0, f(1) = 1$。
  - $f(n) = f(n - 1) + f(n - 2)$，其中 $n > 1$。
- $0 \le n \le 30$。

**示例**：

- 示例 1：

```python
输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
```

- 示例 2：

```python
输入：n = 3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2
```

#### 4.1.3 解题思路

###### 1. 划分阶段

将问题按整数顺序分为 $0$ 到 $n$ 共 $n + 1$ 个阶段，每个阶段对应一个斐波那契数的下标。

###### 2. 定义状态

令 $dp[i]$ 表示第 $i$ 个斐波那契数的值。

###### 3. 状态转移方程

依据斐波那契数列的递推关系 $f(n) = f(n - 1) + f(n - 2)$，可得状态转移方程：$dp[i] = dp[i - 1] + dp[i - 2]$。

###### 4. 初始条件

根据定义，$dp[0] = 0$，$dp[1] = 1$。

###### 5. 最终结果

最终答案为 $dp[n]$，即第 $n$ 个斐波那契数。

#### 4.1.4 代码

```python
class Solution:
    def fib(self, n: int) -> int:
        # 边界情况，n 为 0 或 1 时直接返回 n
        if n <= 1:
            return n

        # 初始化 dp 数组，长度为 n+1，dp[i] 表示第 i 个斐波那契数
        dp = [0 for _ in range(n + 1)]
        dp[0] = 0  # 第 0 个斐波那契数为 0
        dp[1] = 1  # 第 1 个斐波那契数为 1
        # 状态转移，从第 2 项开始递推
        for i in range(2, n + 1):
            dp[i] = dp[i - 2] + dp[i - 1]  # 状态转移方程

        return dp[n]  # 返回第 n 个斐波那契数
```

#### 4.1.5 复杂度分析

- **时间复杂度**：$O(n)$。仅需一次循环遍历所有状态，整体时间复杂度为 $O(n)$。
- **空间复杂度**：$O(n)$。由于使用了一维数组 $dp$ 存储每个阶段的状态，因此空间复杂度为 $O(n)$。

### 4.2 经典例题：爬楼梯

#### 4.2.1 题目链接

- [70. 爬楼梯 - 力扣](https://leetcode.cn/problems/climbing-stairs/)

#### 4.2.2 题目大意

**描述**：假设你正在爬楼梯。需要 $n$ 阶你才能到达楼顶。每次你可以爬 $1$ 或 $2$ 个台阶。现在给定一个整数 $n$。

**要求**：计算出有多少种不同的方法可以爬到楼顶。

**说明**：

- $1 \le n \le 45$。

**示例**：

- 示例 1：

```python
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

- 示例 2：

```python
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

#### 4.2.3 解题思路

###### 1. 划分阶段

将问题按台阶数分阶段，阶段范围为 $0 \sim n$ 阶。

###### 2. 定义状态

设 $dp[i]$ 表示到达第 $i$ 阶台阶的不同方法数。

###### 3. 状态转移方程

每次只能爬 $1$ 或 $2$ 个台阶，因此到达第 $i$ 阶的方法可以从第 $i - 1$ 阶爬 $1$ 阶，或从第 $i - 2$ 阶爬 $2$ 阶而来。状态转移方程为：$dp[i] = dp[i - 1] + dp[i - 2]$。

###### 4. 初始条件

- $dp[0] = 1$：从地面（第 $0$ 阶）出发，有 $1$ 种方式（不动）。
- $dp[1] = 1$：只爬 $1$ 阶，有 $1$ 种方式。
- $dp[2] = 2$：可以一次爬 $2$ 阶，或两次各爬 $1$ 阶，共 $2$ 种方式。

###### 5. 最终结果

最终答案为 $dp[n]$，即到达第 $n$ 阶（楼顶）的方案数。

虽然本题与斐波那契数列的状态转移方程相同（$dp[i] = dp[i - 1] + dp[i - 2]$），但考察的实际场景和建模方式有所不同，体现了动态规划在不同问题中的灵活应用。

#### 4.2.4 代码

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        # 初始化 dp 数组，dp[i] 表示到达第 i 阶的方法数
        dp = [0 for _ in range(n + 1)]
        dp[0] = 1  # 到达第 0 阶只有 1 种方式（不动）
        dp[1] = 1  # 到达第 1 阶只有 1 种方式（一步到达）
        # 从第 2 阶开始，依次计算每一阶的方案数
        for i in range(2, n + 1):
            # 状态转移：到达第 i 阶的方法数 = 到达第 i - 1 阶的方法数 + 到达第 i - 2 阶的方法数
            dp[i] = dp[i - 1] + dp[i - 2]
        
        return dp[n]  # 返回到达第 n 阶的方法总数
```

#### 4.2.5 复杂度分析

- **时间复杂度**：为 $O(n)$，因为只需一重循环遍历 $n$ 次即可完成计算。
- **空间复杂度**：为 $O(n)$，由于需要一个长度为 $n + 1$ 的一维数组来保存每一级台阶的状态。不过，由于每次状态转移只依赖于前两项 $dp[i - 1]$ 和 $dp[i - 2]$，因此可以进一步优化，只用三个变量分别记录当前和前两步的状态，将空间复杂度降为 $O(1)$。

## 5. 总结

动态规划通过「阶段 — 状态 — 转移」的框架，将含有重叠子问题的最优化任务转化为可递推求解的表格计算。它适用于同时满足最优子结构、重叠子问题与无后效性的场景，核心在于合理设计状态与状态转移方程，并明确初始与边界条件。

实际解题时，先判断是否符合三大特征，再按步骤完成：划分阶段、定义状态、写出转移、设定初始 / 边界、提取答案。实现可采用自顶向下（记忆化）或自底向上（迭代）两种方式，并视依赖关系进行空间优化。

本文以斐波那契与爬楼梯为例，展示了从建模到实现的完整路径。理解这些基本范式后，多练习与归纳是提升动态规划能力的关键，尤其要学会在不同问题背景下复用“状态设计+转移关系”的思维模板。

## 题目练习

- [0509. 斐波那契数](https://github.com/ITCharge/AlgoNote/tree/main/docs/solutions/0500-0599/fibonacci-number.md)
- [0070. 爬楼梯](https://github.com/ITCharge/AlgoNote/tree/main/docs/solutions/0001-0099/climbing-stairs.md)
- [0062. 不同路径](https://github.com/ITCharge/AlgoNote/tree/main/docs/solutions/0001-0099/unique-paths.md)

- [动态规划基础题目](https://github.com/ITCharge/AlgoNote/tree/main/docs/00_preface/00_06_categories_list.md#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE)

## 参考资料

- 【文章】[动态规划基础 - OI Wiki](https://oi-wiki.org/dp/basic/)
- 【文章】[动态规划 1 ——基本概念 - 知乎](https://zhuanlan.zhihu.com/p/25441186)
- 【文章】[动态规划算法 | 曹世宏的博客](https://cshihong.github.io/2018/03/30/动态规划算法/)
- 【文章】[动态规划之初识动规：有了四步解题法模板，再也不害怕动态规划！ - 知乎](https://zhuanlan.zhihu.com/p/91680256)
- 【文章】[第 6 节 最优子结构、重复子问题、无后效性 | 算法吧](https://suanfa8.com/dynamic-programming/06/)
- 【书籍】算法训练营 陈小玉 著
- 【书籍】趣学算法 陈小玉 著
- 【书籍】算法竞赛进阶指南 - 李煜东 著
- 【书籍】ACM-ICPC 程序设计系列 - 算法设计与实现 - 陈宇 吴昊 主编
